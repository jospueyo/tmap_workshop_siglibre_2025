---
title: "Haz un mapa web interactivo con tres líneas de código en R"
format: html
---

# Lo prometido es deuda...

```{r}
#| output: false

# install.packages("tmap")
library(tmap)
tmap_mode("view")
qtm(World, fill = "HPI")

```

```{r}
#| eval: false
rios <- readRDS("data/rios_cat.rds")
qtm(rios, col = "ORDRE")

```

<iframe src="rios.html" width="100%" height="500px"></iframe>

```{r}

qtm(World, fill = "HPI", fill.scale = tm_scale_continuous(values = "-brewer.bu_pu"))

```

```{r}

(hpi_world <- qtm(
    World, 
    fill = "HPI", 
    fill.scale = tm_scale_continuous(values = "brewer.bu_pu"),
    fill.legend = tm_legend(
        title = "Happy Planet Index",
        orientation = "landscape",
        position = c("center", "bottom"),
        na.show = FALSE,
        frame = FALSE
    )
))

## Consultar paletas disponibles
# cols4all::c4a_gui()
# cols4all::c4a_palettes()
```

```{r}
#| eval: false

tmap_save(hpi_world, "maps/hpi.html")
```

# Ahora empezamos de verdad

<https://r-tmap.github.io/tmap/articles/foundations_gg>

```{r}

tm_shape(World) +
    # tm_crs("+proj=eqearth") +
    tm_polygons(
        fill = "HPI", 
        fill.scale = tm_scale_continuous(
            values = cols4all::c4a_palettes()[sample(1:595, 1)]
            )
        )
    # tm_grid()
    # tm_symbols(size = "gdp_cap_est", fill = "black") + 
    # tm_basemap(leaflet::providers$Stadia.StamenWatercolor) +
    # tm_scalebar(position = c("left", "bottom")) +
    # tm_logo(
    #     file = "https://www.jornadassiglibre.org/wp-content/uploads/2024/10/SIGLIBRE-motiu.png",
    #     height = 3,
    #     position = c("right", "top")
    #     )

```

https://leaflet-extras.github.io/leaflet-providers/preview/

```{r}

World$size_class <- with(World, ifelse(pop_est > median(pop_est), "Big", "Small"))

tm_shape(World) +
    tm_polygons(fill = "HPI") +
    tm_facets("size_class")

```

Si queremos hacer mapas, no podemos hacerlos sin los básicos.

```{r}

library(sf)
library(terra)
library(dplyr)

archivos <- file.path("data", list.files("data"))

# cargamos todos los archivos en data y los asignamos a una variable con el mismo nombre
for (archivo in archivos){
    assign(
        sub(".rds", "", basename(archivo)), 
        readRDS(archivo)
    )
}

# Simplificamos municipis para reducir tiempo de computación
munis_cat <- st_simplify(munis_cat, dTolerance = 10, preserveTopology = TRUE)

```

Combinamos un raster con un vectorial

```{r}
#| eval: false

(usos_suelo <- tm_shape(usos_suelo) +
        tm_raster() +
    tm_shape(comarc_cat) +
        tm_polygons(fill = NULL))
tmap_save(usos_suelo, "maps/usos-suelo.html")
```

<iframe src="usos-suelo.html" width="100%" height="500px"></iframe>

Le añadimos un poco de magia

```{r}
#| eval: false
#| fig-height: 8

# Contamos frecuencia de usos del suelo por comarca
usos_comarca <- freq(usos_suelo, zones = vect(comarc_cat))

# Unimos el recuento con el tesaurus de usos
usos_comarca2 <- usos_comarca |> 
    left_join(tesaurus_usos, by = join_by("value" == "id")) |> 
    mutate(
        perc = paste0(round(count / sum(count) * 100, 1), "%"),
        .by = zone
        ) |> 
    select(coberta, zone, perc)

# Unimos el recuento con la capa de comarcas
comarc_usos <- comarc_cat |> 
    select(-c(CODICOMAR, AREACOMAR, DATAALTA)) |> 
    right_join(usos_comarca2, by = join_by(ID == zone)) |> 
    tidyr::pivot_wider(names_from = coberta, values_from = perc, values_fill = "0%")

# Extraemos los colores predefinidos en el raster de usos del suelo
colores <- coltab(usos_suelo)[[1]][2:26, ]
colores_hex <- rgb(colores$red, colores$green, colores$blue, maxColorValue = 255)
categorias <- tesaurus_usos$coberta


(usos_suelo_leyenda <- tm_shape(usos_suelo) +
        tm_raster() +
    tm_shape(comarc_usos) +
        tm_polygons(fill = NULL) +
    tm_add_legend(
        labels = categorias,
        type = "polygons",
        fill = colores_hex
    ))
tmap_save(usos_suelo_leyenda, "maps/usos-suelo-leyenda.html")
```

<iframe src="usos-suelo-leyenda.html" width="100%" height="800px"></iframe>

Podemos controlar la visibilidad según el nivel de zoom

```{r}
#| eval: false

(zoom_control <- tm_shape(munis_cat) +
        tm_polygons(fill = "AREAPOL", group = "Municipios") +
        tm_text(text = "NOM_MUNI", group = "Municipios") +
    tm_shape(comarc_cat) +
        tm_polygons(fill = "AREACOMAR", group = "Comarcas") +
        tm_text(text = "NOM_COMAR", group = "Medio") +
    tm_shape(ciudades_cat) +
        tm_dots(group = "Comarcas", fill = "darkred") +
        tm_text(text = "Nom", group = "Comarcas", col = "darkred") +
    tm_group("Municipios", zoom_levels = 11:20) +
    tm_group("Comarcas", zoom_levels = 8:10) +
    tm_group("Medio", zoom_levels = 9:10) +
    tm_view(set_zoom_limits = c(8, 20)))
tmap_save(zoom_control, "maps/zoom-control.html")
```

<iframe src="zoom-control.html" width="100%" height="700px"></iframe>

Aunque no son mapas web interactivos, también podemos crear animaciones.


```{r}
#| eval: false

pob_json <- jsonlite::read_json("https://api.idescat.cat/taules/v2/pmh/446/477/mun/data?YEAR=1999,2004,2009,2014,2019,2024&SEX=TOTAL")

# Convertimos NULL a NA para no perder dats con unlist
pob_json$value[sapply(pob_json$value, is.null)] <- NA
value <- unlist(pob_json$value)
years <- unlist(pob_json$dimension$YEAR$category$index)
munis <- unlist(pob_json$dimension$MUN$category$index)

poblacion <- tibble(
    municipio = rep(munis, length(years)),
    ano = rep(years, each = length(munis)),
    poblacion = value
)

evol_pobl <- munis_cat |> 
evol_pobl <- munis_cat |> 
    left_join(poblacion, by = join_by(MUNICIPI == municipio)) |>
    tm_shape() +
    tm_polygons(
        fill = "poblacion", 
        fill.scale = tm_scale_continuous_log10(values = "brewer.bu_pu"),
        ) +
    tm_animate(by = "ano")

# Para incluirla en un documento quarto, debemos guardarla como gif (hay otras formas, pero son más complicadas)

tmap_animation(evol_pobl, delay = 100, "maps/evol-poblacion.gif", width = 800, height = 600)

# Para incluirla en un documento quarto, debemos guardarla como gif (hay otras formas, pero son más complicadas)

tmap_animation(evol_pobl, delay = 100, "maps/evol-poblacion.gif", width = 800, height = 600)

```

[](evol-poblacion.gif)

Ahora falseamos la evolución de la población para ver mejor el efecto de la animacion

```{r}
#| eval: false

evol_falseada <- munis_cat |> 
    left_join(poblacion, by = join_by(MUNICIPI == municipio)) |>
    mutate(poblacion_falseada = rep(sample(1:10, n(), replace = TRUE)),
        evolucion = poblacion_falseada + as.numeric(ano)
    ) |> 
    tm_shape() +
    tm_polygons(
        fill = "evolucion", 
        fill.scale = tm_scale_continuous(values = "brewer.bu_pu"),
        ) +
    tm_animate(by = "ano")

tmap_animation(evol_falseada, delay = 100, "maps/evol-falseada.gif", width = 800, height = 600)

```

![](evol-falseada.gif)